<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complex Function Visualization with LAB</title>
    <style>
        #rangeDisplay {
            background: rgba(255, 255, 255, 0.8);
            padding: 5px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 12px;
        }
    </style>
</head>

<body>
    <select id="switcher">
        <option value="arctan">2/π * arctan(r)</option>
        <option value="n1">r/(r + 1)</option>
        <option value="n2">r²/(r² + 1)</option>
        <option value="n3">r³/(r³ + 1)</option>
        <option value="n4">r⁴/(r⁴ + 1)</option>
    </select>
    <label for="colorMode">Use LAB Colors:</label>
    <input type="checkbox" id="colorMode" checked>
    <br>
    <label for="functionInput">Function (use z):</label>
    <input type="text" id="functionInput" value="z.pow(3)" placeholder="e.g., z.pow(3)">
    <button id="updateFunction">Update Function</button>
    <br>
    <div id="rangeDisplay">Range: x: [-5, 5], y: [-5, 5]</div>
    <script type="module">
        import p5 from "p5";
        import convert from "color-convert";

        let lightnessMode = "arctan"; // Default mode
        let useLABColors = true; // Default to LAB colors
        let customFunction = (z) => z.pow(3).sub(new Complex(1, -1)); 
        // I want to animate new Complex(1, range(-1, -2)) in a minute

        new p5((sketch) => {
            sketch.setup = () => {
                sketch.createCanvas(200, 200);
                sketch.pixelDensity(1);
                sketch.noLoop();

                // Event listeners
                document.getElementById("switcher").addEventListener("change", (event) => {
                    lightnessMode = event.target.value;
                    sketch.draw();
                });

                document.getElementById("colorMode").addEventListener("change", (event) => {
                    useLABColors = event.target.checked;
                    sketch.draw();
                });

                document.getElementById("updateFunction").addEventListener("click", () => {
                    const input = document.getElementById("functionInput").value;
                    try {
                        customFunction = new Function("z", "return " + input);
                        sketch.draw();
                    } catch (e) {
                        console.error("Invalid function input:", e);
                        alert("Invalid function input. Please check your syntax.");
                    }
                });
            };

            sketch.draw = () => {
                sketch.loadPixels();
                for (let x = 0; x < sketch.width; x++) {
                    for (let y = 0; y < sketch.height; y++) {
                        // Map pixel position to a complex number z
                        let zx = sketch.map(x, 0, sketch.width, -5, 5);
                        let zy = sketch.map(y, 0, sketch.height, -5, 5);
                        let z = new Complex(zx, zy);

                        // Compute f(z) using the custom function
                        let fz = customFunction(z);

                        // Calculate magnitude (r) and phase (arg) of f(z)
                        let r = fz.mag();
                        let phase = fz.phase();

                        // Map phase to hue
                        let hue = sketch.map(phase, -Math.PI, Math.PI, 0, 360);

                        // Calculate lightness based on the selected mode
                        let lightness;
                        switch (lightnessMode) {
                            case "arctan":
                                lightness = sketch.map((2 / Math.PI) * Math.atan(r), 0, 1, 0, 100);
                                break;
                            case "n1":
                                lightness = sketch.map(r / (r + 1), 0, 1, 0, 100);
                                break;
                            case "n2":
                                lightness = sketch.map((r * r) / (r * r + 1), 0, 1, 0, 100);
                                break;
                            case "n3":
                                lightness = sketch.map((r * r * r) / (r * r * r + 1), 0, 1, 0, 100);
                                break;
                            case "n4":
                                lightness = sketch.map((r * r * r * r) / (r * r * r * r + 1), 0, 1, 0, 100);
                                break;
                            default:
                                lightness = 50; // Fallback
                        }

                        let col;
                        if (useLABColors) {
                            // Convert LAB to RGB
                            let a = 100 * Math.cos(phase); // a* ranges from -100 to 100
                            let b = 100 * Math.sin(phase); // b* ranges from -100 to 100
                            let labColor = [Math.round(lightness), Math.round(a), Math.round(b)];
                            let rgbColor = convert.lab.rgb(labColor);
                            rgbColor = rgbColor.map(val => Math.min(Math.max(val, 0), 255)); // Clamp RGB values
                            sketch.colorMode(sketch.RGB);
                            col = sketch.color(rgbColor[0], rgbColor[1], rgbColor[2]);
                        } else {
                            // Use HSL color wheel
                            sketch.colorMode(sketch.HSB);
                            col = sketch.color(hue, 50, lightness);
                        }

                        sketch.set(x, y, col);
                    }
                }
                sketch.updatePixels();

                // Update the range display
                document.getElementById("rangeDisplay").textContent =
                    `Range: x: [-5, 5], y: [-5, 5]`;
            };
        });

        class Complex {
            constructor(re, im) {
                this.re = re;
                this.im = im;
            }

            add(c) {
                return new Complex(this.re + c.re, this.im + c.im);
            }

            sub(c) {
                return new Complex(this.re - c.re, this.im - c.im);
            }

            mul(c) {
                return new Complex(
                    this.re * c.re - this.im * c.im,
                    this.re * c.im + this.im * c.re
                );
            }

            pow(n) {
                if (typeof n === "number") {
                    let magnitude = Math.pow(this.mag(), n);
                    let phase = this.phase() * n;
                    return new Complex(
                        magnitude * Math.cos(phase),
                        magnitude * Math.sin(phase)
                    );
                } else if (n instanceof Complex) {
                    return this.exp(n.mul(this.ln()));
                } else {
                    throw new Error("Exponent must be a number or a Complex number");
                }
            }

            ln() {
                return new Complex(
                    Math.log(this.mag()),
                    this.phase()
                );
            }

            exp() {
                const expReal = Math.exp(this.re);
                return new Complex(
                    expReal * Math.cos(this.im),
                    expReal * Math.sin(this.im)
                );
            }

            phase() {
                return Math.atan2(this.im, this.re);
            }

            mag() {
                return Math.sqrt(this.re * this.re + this.im * this.im);
            }
        }
    </script>
</body>

</html>