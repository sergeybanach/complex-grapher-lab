<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complex Function Visualization with LAB</title>
    <style>
        #rangeDisplay {
            background: rgba(255, 255, 255, 0.8);
            padding: 5px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 12px;
        }
    </style>
</head>

<body>
    <select id="switcher">
        <option value="arctan">2/π * arctan(r)</option>
        <option value="n1">r/(r + 1)</option>
        <option value="n2">r²/(r² + 1)</option>
        <option value="n3">r³/(r³ + 1)</option>
        <option value="n4">r⁴/(r⁴ + 1)</option>
    </select>
    <label for="colorMode">Use LAB Colors:</label>
    <input type="checkbox" id="colorMode" checked>
    <br>
    <label for="param1Slider">Parameter 1 (Real part):</label>
    <input type="range" id="param1Slider" min="-2" max="2" step="0.01" value="0">
    <span id="param1Value">0.00</span>
    <br>
    <label for="param2Slider">Parameter 2 (Imaginary part):</label>
    <input type="range" id="param2Slider" min="-2" max="2" step="0.01" value="0">
    <span id="param2Value">0.00</span>
    <br>
    <div id="rangeDisplay">Range: x: [-5, 5], y: [-5, 5]</div>
    <script type="module">
        import p5 from "p5";
        import convert from "color-convert";

        let lightnessMode = "arctan"; // Default mode
        let useLABColors = true; // Default to LAB colors
        let param1 = 0; // Default value for parameter 1 (real part)
        let param2 = 0; // Default value for parameter 2 (imaginary part)

        new p5((sketch) => {
            sketch.setup = () => {
                sketch.createCanvas(200, 200);
                sketch.pixelDensity(1);
                sketch.noLoop();

                // Event listeners
                document.getElementById("switcher").addEventListener("change", (event) => {
                    lightnessMode = event.target.value;
                    sketch.draw();
                });

                document.getElementById("colorMode").addEventListener("change", (event) => {
                    useLABColors = event.target.checked;
                    sketch.draw();
                });

                // Slider input listeners for param1 and param2
                const param1Slider = document.getElementById("param1Slider");
                const param1ValueDisplay = document.getElementById("param1Value");
                param1Slider.addEventListener("input", (event) => {
                    param1 = parseFloat(event.target.value); // Update param1
                    param1ValueDisplay.textContent = param1.toFixed(2); // Update display
                    sketch.draw(); // Redraw the canvas
                });

                const param2Slider = document.getElementById("param2Slider");
                const param2ValueDisplay = document.getElementById("param2Value");
                param2Slider.addEventListener("input", (event) => {
                    param2 = parseFloat(event.target.value); // Update param2
                    param2ValueDisplay.textContent = param2.toFixed(2); // Update display
                    sketch.draw(); // Redraw the canvas
                });
            };

            sketch.draw = () => {
                sketch.loadPixels();
                for (let x = 0; x < sketch.width; x++) {
                    for (let y = 0; y < sketch.height; y++) {
                        // Map pixel position to a complex number z
                        let zx = sketch.map(x, 0, sketch.width, -5, 5);
                        let zy = sketch.map(y, 0, sketch.height, -5, 5);
                        let z = new Complex(zx, zy);

                        // Compute f(z) = z^2 + (param1 + param2*i)
                        // let fz = z.pow(4).add(new Complex(param1, param2));
                        let fz = z.pow(new Complex(param1, param2));

                        // Calculate magnitude (r) and phase (arg) of f(z)
                        let r = fz.mag();
                        let phase = fz.phase();

                        // Map phase to hue
                        let hue = sketch.map(phase, -Math.PI, Math.PI, 0, 360);

                        // Calculate lightness based on the selected mode
                        let lightness;
                        switch (lightnessMode) {
                            case "arctan":
                                lightness = sketch.map((2 / Math.PI) * Math.atan(r), 0, 1, 0, 100);
                                break;
                            case "n1":
                                lightness = sketch.map(r / (r + 1), 0, 1, 0, 100);
                                break;
                            case "n2":
                                lightness = sketch.map((r * r) / (r * r + 1), 0, 1, 0, 100);
                                break;
                            case "n3":
                                lightness = sketch.map((r * r * r) / (r * r * r + 1), 0, 1, 0, 100);
                                break;
                            case "n4":
                                lightness = sketch.map((r * r * r * r) / (r * r * r * r + 1), 0, 1, 0, 100);
                                break;
                            default:
                                lightness = 50; // Fallback
                        }

                        let col;
                        if (useLABColors) {
                            // Convert LAB to RGB
                            let a = 100 * Math.cos(phase); // a* ranges from -100 to 100
                            let b = 100 * Math.sin(phase); // b* ranges from -100 to 100
                            let labColor = [Math.round(lightness), Math.round(a), Math.round(b)];
                            let rgbColor = convert.lab.rgb(labColor);
                            rgbColor = rgbColor.map(val => Math.min(Math.max(val, 0), 255)); // Clamp RGB values
                            col = sketch.color(rgbColor[0], rgbColor[1], rgbColor[2]);
                            sketch.colorMode(sketch.RGB);
                        } else {
                            // Use HSL color wheel
                            col = sketch.color(hue, 50, lightness);
                            sketch.colorMode(sketch.HSB);
                        }

                        sketch.set(x, y, col);
                    }
                }
                sketch.updatePixels();

                // Update the range display
                document.getElementById("rangeDisplay").textContent =
                    `Range: x: [-5, 5], y: [-5, 5] | Param1: ${param1.toFixed(2)}, Param2: ${param2.toFixed(2)}`;
            };
        });

        class Complex {
            constructor(re, im) {
                this.re = re;
                this.im = im;
            }

            add(c) {
                return new Complex(this.re + c.re, this.im + c.im);
            }

            mul(c) {
                return new Complex(
                    this.re * c.re - this.im * c.im,
                    this.re * c.im + this.im * c.re
                );
            }

            pow(c) {
                // return this.exp(c.mul(this.ln()));
                return c.mul(this.ln()).exp();

            }

            ln() {
                return new Complex(
                    Math.log(this.mag()),
                    this.phase()
                );
            }

            exp() {
                const expReal = Math.exp(this.re);
                return new Complex(
                    expReal * Math.cos(this.im),
                    expReal * Math.sin(this.im)
                );
            }

            phase() {
                return Math.atan2(this.im, this.re);
            }

            mag() {
                return Math.sqrt(this.re * this.re + this.im * this.im);
            }
        }
    </script>
</body>

</html>